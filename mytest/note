使用detected_complted进行检测控制。如果该项大于1,则已经检测出来了，不需要检测。如果不等于，无论是否检测出来都需要再检测。
如果在没检测出来的时候需要打印流的具体信息，可以先guess。这里有个bug，如果不需要打印详细信息，那么不guess，最后guess，这样这个流会一直被检测。但是如果先guess了，flow->detected_protocol会变，当包数量大于8后，就会是这个guess结果，之后不会再检测了。也就是，如果某个包在8个以前可以guess出来，但是检测不出来的话，使用verbose模式，会使用8个包前的guess结果，而普通模式会一检测。
第二个bug是自己造成的。
demo给的用来保存flow指针的root数组是struct *ndpi_flow类型的
而我的是u_int32_t类型的，在32位系统没有问题，但是在64位，指针长度变了，所以会溢出。
